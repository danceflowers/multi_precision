# Multi Precision（MP-RCU）项目说明文档

## 1. 项目概述

`multi_precision` 是一个 **多精度可重构计算单元（MP-RCU）** 的 C++ 行为级仿真工程，面向“硬件映射友好”的算术验证。它支持：

- 整数 SIMD（4/8/16/32 bit lane）加法、乘法、MAC。
- 浮点（FP32、双路 FP16）加法、减法、乘法、FMA（MAC 路径）。
- 复数（FP16 实部+虚部）乘法。
- 非线性运算（FP32 除法、平方根）的 Newton-Raphson 迭代模型。
- 统一 96-bit 累加器视图（96/48/24/12 bit alias 访问）。
- Pack 单元输出缩放、舍入、饱和。

整体数据流：

`input_a / input_b -> stage1_unpack -> stage2_compute -> stage3_accumulate -> stage4_nonlinear(可选) -> stage5_pack -> output_z`

---

## 2. 快速使用

### 2.1 构建

```bash
make
```

生成可执行文件：`mprcu_sim`

### 2.2 运行

```bash
make run
# 或
./mprcu_sim
```

运行后会执行 `main.cpp` 中全部测试：FP32 基本/特殊值/次正规、FP16、复数、整数 SIMD、Pack 饱和、累加器视图等。

### 2.3 清理

```bash
make clean
```

---

## 3. 目录与模块职责

- `mprcu_types.h`：配置枚举、状态寄存器、96-bit 累加器结构、位转换工具。
- `soft_float_engine.h/.cpp`：软浮点核心与整数 SIMD 算术实现。
- `pack_unit.h/.cpp`：输出缩放、舍入、饱和、按精度打包。
- `mprcu_top.h/.cpp`：顶层“流水 + FSM”调度，模拟一个周期推进。
- `main.cpp`：回归测试入口与检查函数。
- `Makefile`：构建规则。

---

## 4. 类型、类与函数逐项说明（含实现方法）

> 说明原则：按“文件 -> 类/结构 -> 函数”组织。每个函数给出**功能**与**实现方法**。

## 4.1 `mprcu_types.h`

### 4.1.1 枚举与结构

#### `enum class Mode`
- 功能：选择运算模式（`INTEGER`/`FLOAT`/`COMPLEX`）。
- 实现方法：作为 `CfgReg.mode` 输入，在 `MPRCU_Top::stage1_unpack` 与 `stage2_compute` 的 `switch` 分支中决定解包和算术路径。

#### `enum class Precision`
- 功能：选择数据并行粒度（P4/P8/P16/P32）。
- 实现方法：用于 SIMD lane 划分、FP16/FP32 分支与 pack 逻辑选择。

#### `enum class Operation`
- 功能：选择运算（ADD/MUL/MAC/DIV/SQRT）。
- 实现方法：在计算阶段决定调用哪一个算术内核；DIV/SQRT 进入非线性 FSM。

#### `enum class RoundMode`
- 功能：定义 IEEE-754 舍入模式。
- 实现方法：传递到 `SoftFloatEngine::pack_fpXX/apply_rounding` 与 `PackUnit::scale_and_round`。

#### `enum class NLState`
- 功能：非线性单元状态（IDLE/CALC/DONE）。
- 实现方法：`MPRCU_Top::step` 中状态机推进，DIV/SQRT 多周期完成。

#### `struct CfgReg`
- 功能：聚合配置寄存器字段。
- 实现方法：`MPRCU_Top` 在 `execute` 中写入，流水阶段读取。

#### `struct StatusReg`
- 功能：聚合状态寄存器（busy/overflow/underflow/nan/inf/cycle_cnt）。
- 实现方法：`step` 周期计数自增，运算完成后由结果分类逻辑置位标志。

### 4.1.2 `struct AccumulatorFile`

#### `void clear()`
- 功能：清空 96-bit 累加器。
- 实现方法：直接将 `data[0..2]` 置 0。

#### `void write96(uint64_t lo64, uint32_t hi32)`
- 功能：按 64+32 bit 写入完整 96-bit。
- 实现方法：`lo64` 低/高 32 bit 分别写 `data[0]/data[1]`，`hi32` 写 `data[2]`。

#### `void read96(uint64_t &lo64, uint32_t &hi32) const`
- 功能：读取完整 96-bit。
- 实现方法：拼接 `data[1]<<32 | data[0]` 得 `lo64`，`data[2]` 得 `hi32`。

#### `void write48(int idx, uint64_t val)` / `uint64_t read48(int idx) const`
- 功能：2 路 48-bit 视图读写（常用于 FP16 双路路径）。
- 实现方法：
  - `idx=0` 映射 `data[0] + data[1]低16`。
  - `idx=1` 映射 `data[1]高16 + data[2]`。
  - 使用掩码保留未覆盖半字。

#### `void write24(int idx, uint32_t val)` / `uint32_t read24(int idx) const`
- 功能：4 路 24-bit 视图读写。
- 实现方法：通过索引定位到 `data` 的对应 bit 切片，分段掩码更新。

#### `void write12(int idx, uint16_t val)` / `uint16_t read12(int idx) const`
- 功能：8 路 12-bit 视图读写（P4 场景等）。
- 实现方法：按 12-bit lane 编号计算 bit 偏移，组合位运算更新/提取。

### 4.1.3 工具函数

#### `uint32_t float_to_bits(float f)`
- 功能：`float` 到位模式转换。
- 实现方法：`memcpy` 保持严格别名安全。

#### `float bits_to_float(uint32_t u)`
- 功能：位模式到 `float` 转换。
- 实现方法：`memcpy` 回写浮点。

---

## 4.2 `soft_float_engine.h/.cpp`

### 4.2.1 内部数据结构

#### `struct FPUnpacked`
- 功能：浮点拆包中间态（符号、指数、尾数、零/无穷/NaN/次正规标志）。
- 实现方法：由 `unpack_fp32/unpack_fp16` 生成，后续算术与 pack 全程使用。

### 4.2.2 基础辅助

#### `int clz32(uint32_t x)` / `int clz64(uint64_t x)`
- 功能：前导零计数。
- 实现方法：分段左移 + 掩码判断，`clz64` 复用 `clz32`。

#### `uint64_t apply_rounding(uint64_t mantissa, int round_bit_pos, RoundMode rm, uint32_t sign)`
- 功能：按 RNE/RTZ/RTP/RTN 对扩展尾数舍入。
- 实现方法：提取 guard/round/sticky；根据模式决定是否进位；实现 ties-to-even。

### 4.2.3 拆包与打包

#### `FPUnpacked unpack_fp32(uint32_t bits)`
- 功能：拆解 FP32 为统一中间格式。
- 实现方法：解析 sign/exp/mant，区分 normal/subnormal/zero/inf/nan，并处理 hidden-1。

#### `FPUnpacked unpack_fp16(uint16_t bits)`
- 功能：拆解 FP16。
- 实现方法：与 FP32 同框架，替换偏置和位宽。

#### `uint32_t pack_fp32(const FPUnpacked &fp, RoundMode rm)`
- 功能：中间格式封装回 FP32。
- 实现方法：处理 NaN/Inf/Zero；正规化；下溢到次正规；应用舍入后写入 exponent+mantissa。

#### `uint16_t pack_fp16(const FPUnpacked &fp, RoundMode rm)`
- 功能：中间格式封装回 FP16。
- 实现方法：与 FP32 同逻辑，使用 FP16 位宽与偏置。

### 4.2.4 FP32 算术

#### `uint32_t fp32_add(uint32_t a, uint32_t b, RoundMode rm)`
- 功能：FP32 加法。
- 实现方法：
  1) 拆包并处理特殊值。
  2) 对阶（小指数右移并生成 sticky）。
  3) 同号加、异号减。
  4) 规格化（左/右归一化）。
  5) pack + 舍入。

#### `uint32_t fp32_sub(uint32_t a, uint32_t b, RoundMode rm)`
- 功能：FP32 减法。
- 实现方法：翻转 `b` 符号位后复用 `fp32_add`。

#### `uint32_t fp32_mul(uint32_t a, uint32_t b, RoundMode rm)`
- 功能：FP32 乘法。
- 实现方法：
  1) 特殊值优先（NaN/Inf/Zero）。
  2) 符号异或，指数相加减偏置。
  3) 尾数乘法得到扩展积。
  4) 规格化与舍入打包。

#### `uint32_t fp32_fma(uint32_t a, uint32_t b, uint32_t acc, RoundMode rm)`
- 功能：FP32 融合乘加（`a*b + acc`）。
- 实现方法：
  1) 先计算乘积分量（扩展精度）。
  2) 与 `acc` 对阶后同号加/异号减。
  3) 最终规格化与舍入一次完成，减少中间舍入误差。

### 4.2.5 FP16 算术

#### `uint16_t fp16_add(uint16_t a, uint16_t b, RoundMode rm)`
- 功能：FP16 加法。
- 实现方法：FP32 add 的缩位版本（5-bit 指数，10-bit 尾数）。

#### `uint16_t fp16_sub(uint16_t a, uint16_t b, RoundMode rm)`
- 功能：FP16 减法。
- 实现方法：翻转 `b` 符号复用 `fp16_add`。

#### `uint16_t fp16_mul(uint16_t a, uint16_t b, RoundMode rm)`
- 功能：FP16 乘法。
- 实现方法：FP32 mul 的缩位版本。

### 4.2.6 整数 SIMD

#### `uint32_t int_mul_simd_4b(uint32_t a, uint32_t b)`
- 功能：8 路 4-bit lane 独立乘法。
- 实现方法：循环提取 nibble，相乘后低 4 bit 回写（wrap）。

#### `uint32_t int_mul_simd_8b(uint32_t a, uint32_t b)`
- 功能：4 路 8-bit lane 乘法。
- 实现方法：提取 byte，乘积截断到 8 bit。

#### `uint32_t int_mul_simd_16b(uint32_t a, uint32_t b)`
- 功能：2 路 16-bit lane 乘法。
- 实现方法：提取 halfword，乘积截断到 16 bit。

#### `uint32_t int_mul_32b(uint32_t a, uint32_t b)`
- 功能：32-bit 乘法（低 32 bit）。
- 实现方法：`uint64_t` 相乘后取低位。

#### `uint32_t int_add_simd_4b(uint32_t a, uint32_t b)`
- 功能：8 路 4-bit lane 加法。
- 实现方法：逐 lane 加法并掩码回写。

#### `uint32_t int_add_simd_8b(uint32_t a, uint32_t b)`
- 功能：4 路 8-bit lane 加法。
- 实现方法：逐 byte 加法掩码。

#### `uint32_t int_add_simd_16b(uint32_t a, uint32_t b)`
- 功能：2 路 16-bit lane 加法。
- 实现方法：逐 halfword 加法掩码。

#### `uint32_t int_add_32b(uint32_t a, uint32_t b)`
- 功能：32-bit 加法。
- 实现方法：自然溢出语义。

### 4.2.7 复数与非线性

#### `uint32_t complex_mul_fp16(uint32_t a, uint32_t b, RoundMode rm)`
- 功能：复数乘法（低16=实部，高16=虚部）。
- 实现方法：使用 FP16 乘加构造
  - `real = ar*br - ai*bi`
  - `imag = ar*bi + ai*br`
  并打包为 32-bit。

#### `uint32_t fp32_div_nr(uint32_t a, uint32_t b, RoundMode rm, int iterations)`
- 功能：FP32 除法（Newton-Raphson）。
- 实现方法：
  1) 特殊值处理。
  2) 生成 `1/b` 初值。
  3) 迭代 `x_{n+1}=x_n*(2-b*x_n)`。
  4) `a*x_n` 得到商并打包。

#### `uint32_t fp32_sqrt_nr(uint32_t a, RoundMode rm, int iterations)`
- 功能：FP32 平方根（Newton-Raphson）。
- 实现方法：
  1) 特殊值处理（负数、零、Inf/NaN）。
  2) 估计 `1/sqrt(a)`。
  3) 迭代更新倒平方根。
  4) `sqrt(a)=a*(1/sqrt(a))`。

### 4.2.8 精度转换

#### `uint32_t fp16_to_fp32(uint16_t h)`
- 功能：FP16 扩展到 FP32。
- 实现方法：按类别映射指数/尾数；次正规通过左规恢复有效位后重编码。

#### `uint16_t fp32_to_fp16(uint32_t f, RoundMode rm)`
- 功能：FP32 压缩到 FP16。
- 实现方法：拆包后做位宽收缩、指数重偏置、按舍入模式处理尾数并打包。

---

## 4.3 `pack_unit.h/.cpp`

### `int32_t saturate_signed(int64_t value, int bits)`
- 功能：有符号饱和到指定位宽。
- 实现方法：计算 `[-2^(bits-1), 2^(bits-1)-1]`，超界截断。

### `uint32_t saturate_unsigned(uint64_t value, int bits)`
- 功能：无符号饱和。
- 实现方法：上界 `2^bits-1` 截断。

### `int64_t scale_and_round(int64_t value, int shift_right, RoundMode rm)`
- 功能：缩放并舍入（支持右移和左移）。
- 实现方法：
  - `shift_right<=0` 时左移。
  - 右移时提取被丢弃位并按舍入模式决定增量。

### `uint32_t pack_4bit_simd(const AccumulatorFile&, int, RoundMode)`
- 功能：把累加器数据按 8×4bit 打包输出。
- 实现方法：读取 12-bit 视图 lane，缩放舍入后执行有符号饱和至 4 bit 并拼接。

### `uint32_t pack_8bit_simd(const AccumulatorFile&, int, RoundMode)`
- 功能：按 4×8bit 打包。
- 实现方法：读取 24-bit lane -> 缩放 -> 饱和 -> 拼接。

### `uint32_t pack_16bit_simd(const AccumulatorFile&, int, RoundMode)`
- 功能：按 2×16bit 打包。
- 实现方法：读取 48-bit lane -> 缩放 -> 饱和 -> 拼接。

### `uint32_t pack_32bit(const AccumulatorFile&, int, RoundMode)`
- 功能：输出 32-bit 标量（来自 96-bit 累加器）。
- 实现方法：读取 96-bit，先缩放低位，再依据高位判断符号扩展是否一致并饱和。

### `uint32_t pack_fp16_dual(uint16_t hi, uint16_t lo)`
- 功能：双路 FP16 打包为 32-bit。
- 实现方法：`(hi<<16)|lo`。

### `uint32_t pack(const AccumulatorFile&, Precision, Mode, int, RoundMode)`
- 功能：按精度（并保留 mode 参数接口）分派到对应 pack 函数。
- 实现方法：`switch(Precision)` 路由到 `pack_4/8/16/32bit`。

---

## 4.4 `mprcu_top.h/.cpp`

### 类 `MPRCU_Top`

#### 关键成员
- `input_a/input_b/output_z`：顶层端口。
- `cfg/status`：配置与状态。
- `accumulator`：统一累加器。
- `nl_state/nl_iter_cnt/nl_operand_a/nl_operand_b/nl_result`：非线性 FSM。
- `s1_out/s2_out/s5_packed`：阶段寄存。

#### `MPRCU_Top()`
- 功能：构造初始化。
- 实现方法：调用 `reset()`。

#### `void reset()`
- 功能：复位所有端口、状态、累加器、流水寄存器、FSM。
- 实现方法：显式清零/默认值写入。

#### `void stage1_unpack()`
- 功能：输入解包。
- 实现方法：
  - `INTEGER`：原样送入整数 lane。
  - `FLOAT`：P32 走整字，P16 拆成两路半精度。
  - `COMPLEX`：提取 real/imag 两个 FP16 分量。

#### `void stage2_compute()`
- 功能：统一算术核心。
- 实现方法：
  - INTEGER：按 op+precision 调 `SoftFloatEngine::int_*`。
  - FLOAT：P32 调 `fp32_add/mul/fma`；P16 双 lane 调 `fp16_*`。
  - COMPLEX：目前以 `MUL` 为主，调 `complex_mul_fp16`。
  - DIV/SQRT 不在该阶段直接迭代，由 stage4 处理。

#### `void stage3_accumulate()`
- 功能：将 stage2 结果写入累加器。
- 实现方法：
  - INTEGER MAC：读旧值后累加。
  - FLOAT P32：写入 96-bit 或更新累加结果。
  - FLOAT P16：分 lane 写 48-bit 视图。
  - COMPLEX：按 32-bit 结果写入相应视图。

#### `void stage4_nonlinear_start()`
- 功能：启动 DIV/SQRT 多周期计算。
- 实现方法：锁存操作数，清迭代计数，切 `nl_state=CALC`，`status.busy=true`。

#### `bool stage4_nonlinear_step()`
- 功能：执行一次非线性迭代步。
- 实现方法：计数达到 `cfg.iter_count` 后调用 `fp32_div_nr/fp32_sqrt_nr` 生成 `nl_result`，切换到 DONE 并返回 true。

#### `void stage5_pack()`
- 功能：最终输出打包。
- 实现方法：
  - FLOAT/COMPLEX：通常直通 FP 结果或从累加器取值。
  - INTEGER：调用 `PackUnit::pack`。
  - `output_z = s5_packed`。

#### `void step()`
- 功能：推进一个“时钟周期”。
- 实现方法：
  - `status.cycle_cnt++`。
  - 若处于 `CALC`，仅推进非线性 FSM；完成后打包输出。
  - 否则执行 stage1->stage2->(必要时stage4启动)->stage3->stage5。
  - 更新状态标志（nan/inf/overflow/underflow）。

#### `uint32_t execute(...)`
- 功能：测试友好的一次调用接口。
- 实现方法：写入配置和输入；
  - 对 DIV/SQRT：先 `step()` 启动，再循环 `step()` 直到 FSM 完成。
  - 其他操作：单次 `step()` 返回。

#### `std::string dump_status() const`
- 功能：文本化导出状态寄存器。
- 实现方法：拼接 busy、异常标志、cycle 信息用于调试。

---

## 4.5 `main.cpp`（测试程序）

### 检查辅助函数

#### `check_fp32(const char* name, uint32_t got, uint32_t expected, int ulp_tolerance=0)`
- 功能：比较 FP32 位模式，可容忍 ULP 误差。
- 实现方法：按符号有序映射后计算“可比较整数差”，统计 pass/fail。

#### `check_u32(const char* name, uint32_t got, uint32_t expected)`
- 功能：无符号整值精确比较。
- 实现方法：相等即 PASS，否则 FAIL。

### 测试函数

#### `test_fp32_basic()`
- 功能：验证 FP32 加法/乘法基础正确性。
- 实现方法：覆盖常规值、异号相消、大数+小数对阶场景。

#### `test_fp32_special_cases()`
- 功能：验证 NaN/Inf 语义。
- 实现方法：构造 NaN 传播、Inf ± Inf、0*Inf 等边界。

#### `test_fp32_subnormals()`
- 功能：验证次正规数处理。
- 实现方法：最小次正规参与加法/乘法。

#### `test_fp32_mac()`
- 功能：验证 FP32 FMA 与累加器。
- 实现方法：先清/预置累加器，再执行 MAC 校验结果。

#### `test_fp32_div_sqrt()`
- 功能：验证 NR 除法与平方根。
- 实现方法：设置迭代次数，按 ULP 容差比较。

#### `test_fp16_operations()`
- 功能：验证双路 FP16 SIMD。
- 实现方法：手工打包两个 FP16 lane 做 add/mul。

#### `test_complex_mul()`
- 功能：验证 FP16 复数乘法。
- 实现方法：构造 `(1+2i)*(3+4i)` 等典型用例。

#### `test_integer_simd()`
- 功能：验证整数 SIMD 加法/乘法。
- 实现方法：覆盖 P4/P8/P32。

#### `test_pack_unit()`
- 功能：验证 pack 饱和逻辑。
- 实现方法：直接调用 `PackUnit::saturate_*`。

#### `test_accumulator_views()`
- 功能：验证 96/48/24/12 视图别名一致性。
- 实现方法：写入后从各视图回读比较。

#### `int main()`
- 功能：测试入口。
- 实现方法：顺序调用全部测试并打印汇总，通过失败计数决定返回码。

---

## 5. 典型调用示例

```cpp
MPRCU_Top dut;
uint32_t a = float_to_bits(1.5f);
uint32_t b = float_to_bits(2.25f);

uint32_t z = dut.execute(
    a, b,
    Mode::FLOAT,
    Precision::P32,
    Operation::ADD,
    RoundMode::ROUND_NEAREST_EVEN,
    4
);
```

- `execute` 在 ADD/MUL/MAC 情况下通常只需 1 个 `step`。
- DIV/SQRT 会根据 `iterations` 自动循环多次 `step`。

---

## 6. 功能边界与注意事项

1. 当前非线性算子（DIV/SQRT）为行为模型，精度受迭代次数影响。
2. 整数 SIMD 为“按 lane 截断/回绕”语义，不做跨 lane 进位。
3. Pack 饱和是输出阶段行为，不改变中间累加器原始值。
4. 状态位（overflow/underflow/nan/inf）为仿真层标志，不等同具体 ISA 的异常标志寄存器定义。

---

## 7. 建议扩展方向

- 增加 FMA 的更多 corner case（符号零、不同舍入模式）。
- 为 DIV/SQRT 提供更稳定的初值表以降低迭代次数。
- 抽离测试为独立框架（如 GoogleTest）并加入 CI。
- 补充复数加法、复数 MAC 与更多精度组合。

